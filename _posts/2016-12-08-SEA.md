---
layout: post
title: SEA - The Simple Encryption Algorithm
---

# SEA
The Simple Encryption Algorithm (SEA) is a very very simple symmetrical block cipher designed by me. It has a key and data size of 128-bits, or 16 bytes. It uses some elements from AES, such as a key schedule and the sbox.

# Basic concepts
## Round IV
Each round has a IV "block", which is 128 - bits in size. This adds the random factor to this and makes it much harder to decrypt. Unfortunately, this means that in order to decrypt, you need to know two pieces of information: the key, and the round IV for each round.

## Key Schedule
The key schedule is a group of keys, one for each round. The key is derived from the previous key by XORing the round IV with the previous key. If the result of the XOR operation is 00, then it is set to 01, because multiplying by 0 in a finite field equals 0 and is irreversible using multiplication, which is not what we want.

# Basic operations
## SubBytes
SubBytes (substitute bytes) operates on the same idea as AES. In fact, it uses the same sbox table as AES, since the sbox for AES was designed for security.

When encrypting, replace each byte with the corresponding byte in the sbox.

When decrypting, replace each byte with the corresponding byte in the inverse sbox.

## MixCells
Here, we rearrange cells within a columns.

The first row remains constant. The second column is shifted by one. The third is shifted by two, and the fourth column is shifted by two. The direction it is shifted depends on whether you are encrypting or decrypting. For encrypting, you shift up. When decrypting, you shift down.

## XORBytes
In this step, we XOR the data output from the previous step with the round key. The operations for this step are the same for both encrypting and decrypting.

## GaloisMult
In this step, we multiply the output from the previous data by the round key, but not using matrix multiplication. I was unable to calculate the inverse of Galois Field in a spreadsheet due to the limited functions, so this is a compromise.

When encrypting, we multiply by the round key. When decrypting, we multiply by the multiplicative inverse of the round key.

# Implementation in Google Sheets
As with the AES post, I will not explain every little detail. Here, I will go over the special things I had to do

## GMUL
If you read the AES post first, you might remember that I had a lookup table for multiplication in a Galois Field. However, the table only covered multiplication by 02, 03, 09, 0B, 0D, and 0E. SEA multiplies by any value from 00 to FF, and thus would a require a lookup table of 256^2, which would have 65,563 entries, way too big for a simple lookup.

Unfortunately, this means that we have to use a script. This function takes two hexadecimal strings and multiplies it in a Galois Field of size 2^8, and returns a hexadecimal answer.

The script is below:

```
function GMUL(a, b) {
    // Convert hex strings into decimal numbers
    var a = parseInt(a, 16);
    var b = parseInt(b, 16);
    var v = new Number;
	v = 0;
	while (b != 0){
		if (b & 1)
			v ^= a;
		b >>= 1;
		if (a & (1 << (8 - 1))){
			a <<= 1;
			a ^= 0x11B;
		} else {
			a <<= 1;
		}
	}
    // Convert number back to hex, uppercase, and pad with zeros
	return pad(v.toString(16).toUpperCase(), 2);
}
```

For the GaloisMult step, we use this function to calculate the new data. Unfortunately, we pay a heavy price in performance. Recalculating everything takes roughly 10 seconds, compared to nearly instant for the much more complicated AES sheet.

## Random IV values
Part of SEA's strength relies on a random round IV for each round. The spreadsheet provides a button that generates random IV values. When pressed, it calls the following function:

```
/*
 * Generates new random values for the round IV table
 */
function generateIV() {
  // Update when IV location in spreadsheet is updated
  var ivrange = "Z15:AC30";

  var ui = SpreadsheetApp.getUi();
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var se = ss.getSheetByName("SEA Encrypt");
  var response = ui.alert('Warning! This may take a while! Your spreadsheet WILL need to reload all the values, which can further increase runtime. Continue?', ui.ButtonSet.YES_NO);

  // Process the user's response.
  if (response == ui.Button.YES) {
    var buffer = generateRandomMatrix(0, 255, 16, 4);
    var range = se.getRange(ivrange);
    var values = range.getValues();
    for (var row in values) {
      for (var col in values[row]) {
        values[row][col] = buffer[row][col];
      }
    }
    range.setValues(values);
    ui.alert('IV updated! Make sure to update the input for the decrypting sheet!', ui.ButtonSet.OK);
  }
}
```

Most of it is setup for reading and writing to a spreadsheet. The interesting parts are `var buffer = generateRandomMatrix(0, 255, 16, 4);` and `values[row][col] = buffer[row][col];`

generateRandomMatrix is the one that actually matters.

```
/*
 * Generates a matrix with random hex values
 * @param {Number} min - Minimum random value (inclusive)
 * @param {Number} max - Maximum random value (inclusive)
 * @param {Number} rows - Number of rows in the matrix
 * @param {Number} columns - Number of columns in the matrix
 * @returns {Matrix} - A two dimensional matrix of size row x columns with random values
 */
function generateRandomMatrix(min, max, rows, columns) {
  var buffer = [];
  for (var i = 0; i < rows; i++) {
    buffer[i] = [];
    for (var r = 0; r < columns; r++) {
      buffer[i][r] = 0;
    }
  }
  for (var row in buffer) {
    for (var col in buffer[row]) {
      buffer[row][col] = pad((Math.floor(Math.random() * (max - min + 1)) + min).toString(16).toUpperCase(), 2);
      Logger.log(buffer[row][col]);
    }
  }
  return buffer;
}
```

This function generates a matrix filled with random hex values, which is then inserted back into the spreadsheet.
